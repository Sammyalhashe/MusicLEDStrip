package com.example.audiocapture;

import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;

import com.example.audiocapture.Components.VisualizerView;
import com.example.audiocapture.Services.VisualizerService;
import com.example.audiocapture.WaveformRenderer.SimpleWaveformRendererFactory;
import com.example.audiocapture.databinding.ActivityMainBinding;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.snackbar.Snackbar;

import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.databinding.BindingAdapter;
import androidx.databinding.DataBindingUtil;

import android.os.IBinder;
import android.util.Log;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;

import java.util.ArrayList;
import java.util.List;

import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.functions.BiFunction;
import io.reactivex.observers.DisposableObserver;

import static androidx.core.app.ActivityCompat.requestPermissions;

public class MainActivity extends AppCompatActivity {

    /** static constants of this class */
    // For the logcat
    private static final String TAG = "MAIN ACTIVITY :: ";

    /** Views */
    private VisualizerView visualizerView;
    ActivityMainBinding binding;

    /**
     * private class variables that are related to the Visualizer service
     * and the binding of this class to said service
     */
    private VisualizerService visualizerService;
    private boolean mBound = false;
    private boolean mSampling = false;
    private boolean sampleWaveform = true;
    private boolean sampleFFT = true;

    /** RxJava */
    //
    private final CompositeDisposable disposables = new CompositeDisposable();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, getResources().getString(R.string.main_onCreate));
        setContentView(R.layout.activity_main);
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        /** Request permissions dynamically depending on Android version */
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
            int hasAudioPermission = checkSelfPermission(Manifest.permission.RECORD_AUDIO);
            int hasAudioSettingsPermission = checkSelfPermission(Manifest.permission.MODIFY_AUDIO_SETTINGS);
            List<String> permissions = new ArrayList<>();
            if (hasAudioPermission != PackageManager.PERMISSION_GRANTED) {
                permissions.add(Manifest.permission.RECORD_AUDIO);
            }
            if (hasAudioSettingsPermission != PackageManager.PERMISSION_GRANTED) {
                permissions.add(Manifest.permission.MODIFY_AUDIO_SETTINGS);
            }

            // follow through with the permission request
            if (!permissions.isEmpty()) {
                requestPermissions(permissions.toArray(new String[permissions.size()]), PackageManager.PERMISSION_GRANTED);
            }

            // Setting up Binding
            binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
            binding.setSamplingFFT(this.sampleFFT);
            binding.setSamplingWaveform(this.sampleWaveform);
            binding.setLifecycleOwner(this);

            /**
             *  Initialize the Visualizer view which will display the waveform data
             *  that the visualizer service sends back through RxJava
             */
            this.visualizerView = (VisualizerView) findViewById(R.id.waveform_view);
            SimpleWaveformRendererFactory rendererFactory = new SimpleWaveformRendererFactory();
            this.visualizerView.setWaveformRenderer(rendererFactory.createSimpleWaveformRenderer(this, Color.DKGRAY, Color.GREEN, Color.BLUE));
        }

        /**
         * This code was auto-generated by Android Studio, could be
         * useful later, but for the time being it's being used to make sure
         * my visualizer service is truly running on a background thread and not
         * the main threa.
         */
        FloatingActionButton fab = findViewById(R.id.fab);
        FloatingActionButton fab1 = findViewById(R.id.fab_wave);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (sampleFFT) {
                    Snackbar.make(view, getResources().getText(R.string.main_stopSampleFFT), Snackbar.LENGTH_LONG)
                            .setAction(getResources().getString(R.string.main_sandboxAction), null).show();
                } else {
                    Snackbar.make(view, getResources().getText(R.string.main_sampleFFT), Snackbar.LENGTH_LONG)
                            .setAction(getResources().getString(R.string.main_sandboxAction), null).show();
                }
                sampleFFT = !sampleFFT;
                Log.i(TAG, getResources().getString(R.string.main_FFTOnClickFAB) + sampleFFT);
                binding.setSamplingFFT(sampleFFT);
            }
        });

        fab1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (sampleWaveform) {
                    Snackbar.make(v, getResources().getText(R.string.main_stopSampleWave), Snackbar.LENGTH_LONG)
                            .setAction(getResources().getString(R.string.main_sandboxAction), null).show();
                } else {
                    Snackbar.make(v, getResources().getText(R.string.main_sampleWave), Snackbar.LENGTH_LONG)
                            .setAction(getResources().getString(R.string.main_sandboxAction), null).show();
                }
                sampleWaveform = !sampleWaveform;
                Log.i(TAG, getResources().getString(R.string.main_waveformOnClickFAB) + sampleWaveform);
                binding.setSamplingWaveform(sampleWaveform);
            }
        });
    }

    /**
     * bindSrcCompat()
     * Binds to an xml attribute and "intercepts" an attempt to set a value to that
     * attribute.
     * I need to do this because it was erroring out on basic assignment for my FABs.
     * @param view
     * @param drawable
     */
    @BindingAdapter("app:srcCompat")
    public static void bindSrcCompat(FloatingActionButton view, Drawable drawable) {
        view.setImageDrawable(drawable);
    }


    /**
     * onStart()
     * Lifecycle hook that is called right after onCreate.
     * This creates the intent that is used to bind VisualizerService (a bound service)
     * to the lifecycle of this Activity.
     */
    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, getResources().getString(R.string.main_onStart));
        Intent intent = new Intent(this, VisualizerService.class);
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    /**
     * onStop()
     * Lifecycle hook for an Activity that is called right before onDestroy().
     * I am using it to fully unbind VisualizerService.
     */
    @Override
    protected void onStop() {
        super.onStop();
        unbindService(connection);
    }

    /**
     * onCreateOptionsMenu()
     * This code was autogenerated by Android Studio. It is not a lifecycle method,
     * but it is a method in the Activity class that is normally used to inflate a defined
     * Menu.
     * @param menu
     * @return boolean
     */
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    /**
     * opOptionsItemSelected()
     * Again, autogenerated code. This method acts as a callback for whenever
     * an options item is selected in the menu
     * @param item
     * @return
     */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    /**
     * This instance of the anonymous class ServiceConnection
     * defines callbacks for binding related events between the
     * activity and the service.
     */
    private ServiceConnection connection = new ServiceConnection() {

        /**
         * onServiceConnected()
         * Callback method that is called when a service binds to this Activity
         * In the context of this application, it will mainly be VisulizerService
         * (unless another service will be bound to this Activity as well)
         *
         * Here I grab an instance of the bound service and set the mBound instance var to true.
         * @param componentName
         * @param iBinder - This is the important paramater that is passed in. This parameter allows
         *                one to access the underlying bound service
         */
        @Override
        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
            Log.i(TAG, getResources().getString(R.string.main_visConnected));
            mBound = true;
            VisualizerService.VisualizerBinder binder = (VisualizerService.VisualizerBinder) iBinder;
            visualizerService = binder.getService();
        }

        /**
         * onServiceDisconnected()
         * Called when the bound service is disconnected to this Actiivity.
         * I reset {visualizerService, mBound} instance vars.
         * @param componentName
         */
        @Override
        public void onServiceDisconnected(ComponentName componentName) {
            Log.i(TAG, getResources().getString(R.string.main_visDisconnected));
            mBound = false;
            visualizerService = null;
        }
    };

    /**
     * startSampling()
     *
     * I call this method when the main Activity is ready to contact the bound VisualizerService
     * and request it to start streaming audio data.
     *
     * It requests an RxJava Observable and adds said Observable to the {disposables: Disposables}
     * object to keep track of it (and eventually clear the subscriptions).
     *
     * (I still don't get the naming behind RxJava Classes relative to RxJS - it's kind of weird)
     *     -> I guess it has something to do with Garbage Collection
     * @param view
     */
    public void startSampling(View view) {
        Log.i(TAG, getResources().getString(R.string.main_sampleButtonClicked));
        Log.i(TAG, String.format("%s", mBound));
        // add the Observable subscription to Disposables
        disposables.add(visualizerService.getWaveformObservable()
                .zipWith(visualizerService.getFFTObservable(), new BiFunction<byte[], byte[], byte[][]>() {
                    @Override
                    public byte[][] apply(byte[] bytes, byte[] bytes2) throws Exception {
                        byte[] w1;
                        byte[] w2;
                        if (!sampleWaveform) {
                            w1 = null;
                        } else {
                            w1 = bytes;
                        }

                        if (!sampleFFT) {
                            w2 = null;
                        } else {
                            w2 = bytes2;
                        }
                        return new byte[][]{w1, w2};
                    }
                })
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver<byte[][]>() {

                    /**
                     * Provides the Observer with a new item to observe.
                     * <p>
                     * The {@link Observable} may call this method 0 or more times.
                     * <p>
                     * The {@code Observable} will not call this method again after it calls either {@link #onComplete} or
                     * {@link #onError}.
                     *
                     * @param bytes the item emitted by the Observable
                     */
                    @Override
                    public void onNext(byte[][] bytes) {
                        // set the {visualizerView}'s waveform to display
                        if (visualizerView != null) {
                            visualizerView.setWaveform(bytes);
                        }
                    }

                    /**
                     * Notifies the Observer that the {@link Observable} has experienced an error condition.
                     * <p>
                     * If the {@link Observable} calls this method, it will not thereafter call {@link #onNext} or
                     * {@link #onComplete}.
                     *
                     * @param e the exception encountered by the Observable
                     */
                    @Override
                    public void onError(Throwable e) {

                    }

                    /**
                     * Notifies the Observer that the {@link Observable} has finished sending push-based notifications.
                     * <p>
                     * The {@link Observable} will not call this method if it calls {@link #onError}.
                     */
                    @Override
                    public void onComplete() {

                    }
                }));
        // request VisualizerService to start collecting audiodata
        // NOTE: this data goes to both {websockets, back here to the visualizerView to display}
        if (mBound && !mSampling) mSampling = visualizerService.startCapturingAudio();
        if (mSampling) {
            visualizerService.streamData();
        }
    }
}
